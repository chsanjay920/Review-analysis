//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class Client {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getFoodIdeas(): Observable<Food[]> {
        let url_ = this.baseUrl + "/api/ReviewAnalysis/GetFoodIdeas";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFoodIdeas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFoodIdeas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Food[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Food[]>;
        }));
    }

    protected processGetFoodIdeas(response: HttpResponseBase): Observable<Food[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Food.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addFoodIdeas(body: Food | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ReviewAnalysis/AddFoodIdeas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddFoodIdeas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddFoodIdeas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddFoodIdeas(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getGeneralProblems(): Observable<GeneralProblems[]> {
        let url_ = this.baseUrl + "/api/ReviewAnalysis/GetGeneralProblems";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralProblems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralProblems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralProblems[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralProblems[]>;
        }));
    }

    protected processGetGeneralProblems(response: HttpResponseBase): Observable<GeneralProblems[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GeneralProblems.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addGeneralProblems(body: GeneralProblems | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ReviewAnalysis/AddGeneralProblems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddGeneralProblems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddGeneralProblems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddGeneralProblems(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getMoviesIdeas(): Observable<Movies[]> {
        let url_ = this.baseUrl + "/api/ReviewAnalysis/GetMoviesIdeas";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMoviesIdeas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMoviesIdeas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Movies[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Movies[]>;
        }));
    }

    protected processGetMoviesIdeas(response: HttpResponseBase): Observable<Movies[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Movies.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addMoviesIdeas(body: Movies | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ReviewAnalysis/AddMoviesIdeas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddMoviesIdeas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddMoviesIdeas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddMoviesIdeas(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPoliticsIdeas(): Observable<Politics[]> {
        let url_ = this.baseUrl + "/api/ReviewAnalysis/GetPoliticsIdeas";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPoliticsIdeas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPoliticsIdeas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Politics[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Politics[]>;
        }));
    }

    protected processGetPoliticsIdeas(response: HttpResponseBase): Observable<Politics[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Politics.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addPoliticsIdeas(body: Politics | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ReviewAnalysis/AddPoliticsIdeas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPoliticsIdeas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPoliticsIdeas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddPoliticsIdeas(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getStartupIdeas(): Observable<StartupIdeas[]> {
        let url_ = this.baseUrl + "/api/ReviewAnalysis/GetStartupIdeas";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStartupIdeas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStartupIdeas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StartupIdeas[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StartupIdeas[]>;
        }));
    }

    protected processGetStartupIdeas(response: HttpResponseBase): Observable<StartupIdeas[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StartupIdeas.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addStartupIdeas(body: StartupIdeas | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ReviewAnalysis/AddStartupIdeas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddStartupIdeas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddStartupIdeas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddStartupIdeas(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getTechnologyIdeas(): Observable<Technology[]> {
        let url_ = this.baseUrl + "/api/ReviewAnalysis/GetTechnologyIdeas";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTechnologyIdeas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTechnologyIdeas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Technology[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Technology[]>;
        }));
    }

    protected processGetTechnologyIdeas(response: HttpResponseBase): Observable<Technology[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Technology.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addTechnologyIdeas(body: Technology | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ReviewAnalysis/AddTechnologyIdeas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTechnologyIdeas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTechnologyIdeas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddTechnologyIdeas(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getUniversitiesIdeas(): Observable<Universities[]> {
        let url_ = this.baseUrl + "/api/ReviewAnalysis/GetUniversitiesIdeas";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUniversitiesIdeas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUniversitiesIdeas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Universities[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Universities[]>;
        }));
    }

    protected processGetUniversitiesIdeas(response: HttpResponseBase): Observable<Universities[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Universities.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUniversitiesIdeas(body: Universities | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ReviewAnalysis/AddUniversitiesIdeas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUniversitiesIdeas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUniversitiesIdeas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddUniversitiesIdeas(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getFeedData(): Observable<FeedData[]> {
        let url_ = this.baseUrl + "/api/ReviewAnalysis/GetFeedData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeedData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FeedData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FeedData[]>;
        }));
    }

    protected processGetFeedData(response: HttpResponseBase): Observable<FeedData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FeedData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addReview(body: ReviewsData | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ReviewAnalysis/AddReview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddReview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddReview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddReview(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param guid (optional) 
     * @return Success
     */
    getReviews(guid: string | undefined): Observable<ReviewsData[]> {
        let url_ = this.baseUrl + "/api/ReviewAnalysis/GetReviews?";
        if (guid === null)
            throw new Error("The parameter 'guid' cannot be null.");
        else if (guid !== undefined)
            url_ += "guid=" + encodeURIComponent("" + guid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReviews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReviews(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewsData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewsData[]>;
        }));
    }

    protected processGetReviews(response: HttpResponseBase): Observable<ReviewsData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReviewsData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getWeatherForecast(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeatherForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeatherForecast(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;
        }));
    }

    protected processGetWeatherForecast(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class FeedData implements IFeedData {
    queryId?: string;
    queryUploadedAt?: Date;
    queryCategory?: string | undefined;
    restaurant?: string | undefined;
    foodDescription?: string | undefined;
    foodType?: string | undefined;
    restaurantLocation?: string | undefined;
    moviename?: string | undefined;
    movieStory?: string | undefined;
    movieCast?: string | undefined;
    movieBudget?: number | undefined;
    generalProblemSubject?: string | undefined;
    generalProblemDescription?: string | undefined;
    generalProblemlocation?: string | undefined;
    politicianName?: string | undefined;
    politicalParty?: string | undefined;
    politicianAge?: number | undefined;
    politicianQualification?: string | undefined;
    politicalDescription?: string | undefined;
    startUpTitle?: string | undefined;
    startUpdescription?: string | undefined;
    startUpInvestmentAmount?: number | undefined;
    startUplocation?: string | undefined;
    technologyName?: string | undefined;
    technologyDescription?: string | undefined;
    launchDate?: Date | undefined;
    prize?: number | undefined;
    universityname?: string | undefined;
    courseOffered?: string | undefined;
    universityDescription?: string | undefined;
    universityFee?: number | undefined;
    establishedYear?: Date | undefined;
    universitiesLocation?: string | undefined;

    constructor(data?: IFeedData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.queryId = _data["queryId"];
            this.queryUploadedAt = _data["queryUploadedAt"] ? new Date(_data["queryUploadedAt"].toString()) : <any>undefined;
            this.queryCategory = _data["queryCategory"];
            this.restaurant = _data["restaurant"];
            this.foodDescription = _data["foodDescription"];
            this.foodType = _data["foodType"];
            this.restaurantLocation = _data["restaurantLocation"];
            this.moviename = _data["moviename"];
            this.movieStory = _data["movieStory"];
            this.movieCast = _data["movieCast"];
            this.movieBudget = _data["movieBudget"];
            this.generalProblemSubject = _data["generalProblemSubject"];
            this.generalProblemDescription = _data["generalProblemDescription"];
            this.generalProblemlocation = _data["generalProblemlocation"];
            this.politicianName = _data["politicianName"];
            this.politicalParty = _data["politicalParty"];
            this.politicianAge = _data["politicianAge"];
            this.politicianQualification = _data["politicianQualification"];
            this.politicalDescription = _data["politicalDescription"];
            this.startUpTitle = _data["startUpTitle"];
            this.startUpdescription = _data["startUpdescription"];
            this.startUpInvestmentAmount = _data["startUpInvestmentAmount"];
            this.startUplocation = _data["startUplocation"];
            this.technologyName = _data["technologyName"];
            this.technologyDescription = _data["technologyDescription"];
            this.launchDate = _data["launchDate"] ? new Date(_data["launchDate"].toString()) : <any>undefined;
            this.prize = _data["prize"];
            this.universityname = _data["universityname"];
            this.courseOffered = _data["courseOffered"];
            this.universityDescription = _data["universityDescription"];
            this.universityFee = _data["universityFee"];
            this.establishedYear = _data["establishedYear"] ? new Date(_data["establishedYear"].toString()) : <any>undefined;
            this.universitiesLocation = _data["universitiesLocation"];
        }
    }

    static fromJS(data: any): FeedData {
        data = typeof data === 'object' ? data : {};
        let result = new FeedData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["queryId"] = this.queryId;
        data["queryUploadedAt"] = this.queryUploadedAt ? this.queryUploadedAt.toISOString() : <any>undefined;
        data["queryCategory"] = this.queryCategory;
        data["restaurant"] = this.restaurant;
        data["foodDescription"] = this.foodDescription;
        data["foodType"] = this.foodType;
        data["restaurantLocation"] = this.restaurantLocation;
        data["moviename"] = this.moviename;
        data["movieStory"] = this.movieStory;
        data["movieCast"] = this.movieCast;
        data["movieBudget"] = this.movieBudget;
        data["generalProblemSubject"] = this.generalProblemSubject;
        data["generalProblemDescription"] = this.generalProblemDescription;
        data["generalProblemlocation"] = this.generalProblemlocation;
        data["politicianName"] = this.politicianName;
        data["politicalParty"] = this.politicalParty;
        data["politicianAge"] = this.politicianAge;
        data["politicianQualification"] = this.politicianQualification;
        data["politicalDescription"] = this.politicalDescription;
        data["startUpTitle"] = this.startUpTitle;
        data["startUpdescription"] = this.startUpdescription;
        data["startUpInvestmentAmount"] = this.startUpInvestmentAmount;
        data["startUplocation"] = this.startUplocation;
        data["technologyName"] = this.technologyName;
        data["technologyDescription"] = this.technologyDescription;
        data["launchDate"] = this.launchDate ? this.launchDate.toISOString() : <any>undefined;
        data["prize"] = this.prize;
        data["universityname"] = this.universityname;
        data["courseOffered"] = this.courseOffered;
        data["universityDescription"] = this.universityDescription;
        data["universityFee"] = this.universityFee;
        data["establishedYear"] = this.establishedYear ? this.establishedYear.toISOString() : <any>undefined;
        data["universitiesLocation"] = this.universitiesLocation;
        return data;
    }
}

export interface IFeedData {
    queryId?: string;
    queryUploadedAt?: Date;
    queryCategory?: string | undefined;
    restaurant?: string | undefined;
    foodDescription?: string | undefined;
    foodType?: string | undefined;
    restaurantLocation?: string | undefined;
    moviename?: string | undefined;
    movieStory?: string | undefined;
    movieCast?: string | undefined;
    movieBudget?: number | undefined;
    generalProblemSubject?: string | undefined;
    generalProblemDescription?: string | undefined;
    generalProblemlocation?: string | undefined;
    politicianName?: string | undefined;
    politicalParty?: string | undefined;
    politicianAge?: number | undefined;
    politicianQualification?: string | undefined;
    politicalDescription?: string | undefined;
    startUpTitle?: string | undefined;
    startUpdescription?: string | undefined;
    startUpInvestmentAmount?: number | undefined;
    startUplocation?: string | undefined;
    technologyName?: string | undefined;
    technologyDescription?: string | undefined;
    launchDate?: Date | undefined;
    prize?: number | undefined;
    universityname?: string | undefined;
    courseOffered?: string | undefined;
    universityDescription?: string | undefined;
    universityFee?: number | undefined;
    establishedYear?: Date | undefined;
    universitiesLocation?: string | undefined;
}

export class Food implements IFood {
    id?: number;
    queryId?: string;
    queryUploadedAt?: Date;
    queryCategory?: string | undefined;
    restaurant?: string | undefined;
    description?: string | undefined;
    foodtype?: string | undefined;
    location?: string | undefined;

    constructor(data?: IFood) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.queryId = _data["queryId"];
            this.queryUploadedAt = _data["queryUploadedAt"] ? new Date(_data["queryUploadedAt"].toString()) : <any>undefined;
            this.queryCategory = _data["queryCategory"];
            this.restaurant = _data["restaurant"];
            this.description = _data["description"];
            this.foodtype = _data["foodtype"];
            this.location = _data["location"];
        }
    }

    static fromJS(data: any): Food {
        data = typeof data === 'object' ? data : {};
        let result = new Food();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["queryId"] = this.queryId;
        data["queryUploadedAt"] = this.queryUploadedAt ? this.queryUploadedAt.toISOString() : <any>undefined;
        data["queryCategory"] = this.queryCategory;
        data["restaurant"] = this.restaurant;
        data["description"] = this.description;
        data["foodtype"] = this.foodtype;
        data["location"] = this.location;
        return data;
    }
}

export interface IFood {
    id?: number;
    queryId?: string;
    queryUploadedAt?: Date;
    queryCategory?: string | undefined;
    restaurant?: string | undefined;
    description?: string | undefined;
    foodtype?: string | undefined;
    location?: string | undefined;
}

export class GeneralProblems implements IGeneralProblems {
    id?: number;
    queryId?: string;
    queryUploadedAt?: Date;
    queryCategory?: string | undefined;
    subject?: string | undefined;
    description?: string | undefined;
    location?: string | undefined;

    constructor(data?: IGeneralProblems) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.queryId = _data["queryId"];
            this.queryUploadedAt = _data["queryUploadedAt"] ? new Date(_data["queryUploadedAt"].toString()) : <any>undefined;
            this.queryCategory = _data["queryCategory"];
            this.subject = _data["subject"];
            this.description = _data["description"];
            this.location = _data["location"];
        }
    }

    static fromJS(data: any): GeneralProblems {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralProblems();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["queryId"] = this.queryId;
        data["queryUploadedAt"] = this.queryUploadedAt ? this.queryUploadedAt.toISOString() : <any>undefined;
        data["queryCategory"] = this.queryCategory;
        data["subject"] = this.subject;
        data["description"] = this.description;
        data["location"] = this.location;
        return data;
    }
}

export interface IGeneralProblems {
    id?: number;
    queryId?: string;
    queryUploadedAt?: Date;
    queryCategory?: string | undefined;
    subject?: string | undefined;
    description?: string | undefined;
    location?: string | undefined;
}

export class Movies implements IMovies {
    id?: number;
    queryId?: string;
    queryUploadedAt?: Date;
    queryCategory?: string | undefined;
    moviename?: string | undefined;
    movieStory?: string | undefined;
    cast?: string | undefined;
    budget?: number | undefined;

    constructor(data?: IMovies) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.queryId = _data["queryId"];
            this.queryUploadedAt = _data["queryUploadedAt"] ? new Date(_data["queryUploadedAt"].toString()) : <any>undefined;
            this.queryCategory = _data["queryCategory"];
            this.moviename = _data["moviename"];
            this.movieStory = _data["movieStory"];
            this.cast = _data["cast"];
            this.budget = _data["budget"];
        }
    }

    static fromJS(data: any): Movies {
        data = typeof data === 'object' ? data : {};
        let result = new Movies();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["queryId"] = this.queryId;
        data["queryUploadedAt"] = this.queryUploadedAt ? this.queryUploadedAt.toISOString() : <any>undefined;
        data["queryCategory"] = this.queryCategory;
        data["moviename"] = this.moviename;
        data["movieStory"] = this.movieStory;
        data["cast"] = this.cast;
        data["budget"] = this.budget;
        return data;
    }
}

export interface IMovies {
    id?: number;
    queryId?: string;
    queryUploadedAt?: Date;
    queryCategory?: string | undefined;
    moviename?: string | undefined;
    movieStory?: string | undefined;
    cast?: string | undefined;
    budget?: number | undefined;
}

export class Politics implements IPolitics {
    id?: number;
    queryId?: string;
    queryUploadedAt?: Date;
    queryCategory?: string | undefined;
    politicianName?: string | undefined;
    party?: string | undefined;
    age?: number | undefined;
    qualification?: string | undefined;
    description?: string | undefined;

    constructor(data?: IPolitics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.queryId = _data["queryId"];
            this.queryUploadedAt = _data["queryUploadedAt"] ? new Date(_data["queryUploadedAt"].toString()) : <any>undefined;
            this.queryCategory = _data["queryCategory"];
            this.politicianName = _data["politicianName"];
            this.party = _data["party"];
            this.age = _data["age"];
            this.qualification = _data["qualification"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Politics {
        data = typeof data === 'object' ? data : {};
        let result = new Politics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["queryId"] = this.queryId;
        data["queryUploadedAt"] = this.queryUploadedAt ? this.queryUploadedAt.toISOString() : <any>undefined;
        data["queryCategory"] = this.queryCategory;
        data["politicianName"] = this.politicianName;
        data["party"] = this.party;
        data["age"] = this.age;
        data["qualification"] = this.qualification;
        data["description"] = this.description;
        return data;
    }
}

export interface IPolitics {
    id?: number;
    queryId?: string;
    queryUploadedAt?: Date;
    queryCategory?: string | undefined;
    politicianName?: string | undefined;
    party?: string | undefined;
    age?: number | undefined;
    qualification?: string | undefined;
    description?: string | undefined;
}

export class ReviewsData implements IReviewsData {
    id?: number;
    queryID?: string;
    review?: string | undefined;
    prediction?: string | undefined;
    predictionScore?: number | undefined;

    constructor(data?: IReviewsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.queryID = _data["queryID"];
            this.review = _data["review"];
            this.prediction = _data["prediction"];
            this.predictionScore = _data["predictionScore"];
        }
    }

    static fromJS(data: any): ReviewsData {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["queryID"] = this.queryID;
        data["review"] = this.review;
        data["prediction"] = this.prediction;
        data["predictionScore"] = this.predictionScore;
        return data;
    }
}

export interface IReviewsData {
    id?: number;
    queryID?: string;
    review?: string | undefined;
    prediction?: string | undefined;
    predictionScore?: number | undefined;
}

export class StartupIdeas implements IStartupIdeas {
    id?: number;
    queryId?: string;
    queryUploadedAt?: Date;
    queryCategory?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    investmentAmount?: number | undefined;
    location?: string | undefined;

    constructor(data?: IStartupIdeas) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.queryId = _data["queryId"];
            this.queryUploadedAt = _data["queryUploadedAt"] ? new Date(_data["queryUploadedAt"].toString()) : <any>undefined;
            this.queryCategory = _data["queryCategory"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.investmentAmount = _data["investmentAmount"];
            this.location = _data["location"];
        }
    }

    static fromJS(data: any): StartupIdeas {
        data = typeof data === 'object' ? data : {};
        let result = new StartupIdeas();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["queryId"] = this.queryId;
        data["queryUploadedAt"] = this.queryUploadedAt ? this.queryUploadedAt.toISOString() : <any>undefined;
        data["queryCategory"] = this.queryCategory;
        data["title"] = this.title;
        data["description"] = this.description;
        data["investmentAmount"] = this.investmentAmount;
        data["location"] = this.location;
        return data;
    }
}

export interface IStartupIdeas {
    id?: number;
    queryId?: string;
    queryUploadedAt?: Date;
    queryCategory?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    investmentAmount?: number | undefined;
    location?: string | undefined;
}

export class Technology implements ITechnology {
    id?: number;
    queryId?: string;
    queryUploadedAt?: Date;
    queryCategory?: string | undefined;
    gadgetname?: string | undefined;
    description?: string | undefined;
    launchdate?: Date | undefined;
    prize?: number | undefined;

    constructor(data?: ITechnology) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.queryId = _data["queryId"];
            this.queryUploadedAt = _data["queryUploadedAt"] ? new Date(_data["queryUploadedAt"].toString()) : <any>undefined;
            this.queryCategory = _data["queryCategory"];
            this.gadgetname = _data["gadgetname"];
            this.description = _data["description"];
            this.launchdate = _data["launchdate"] ? new Date(_data["launchdate"].toString()) : <any>undefined;
            this.prize = _data["prize"];
        }
    }

    static fromJS(data: any): Technology {
        data = typeof data === 'object' ? data : {};
        let result = new Technology();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["queryId"] = this.queryId;
        data["queryUploadedAt"] = this.queryUploadedAt ? this.queryUploadedAt.toISOString() : <any>undefined;
        data["queryCategory"] = this.queryCategory;
        data["gadgetname"] = this.gadgetname;
        data["description"] = this.description;
        data["launchdate"] = this.launchdate ? this.launchdate.toISOString() : <any>undefined;
        data["prize"] = this.prize;
        return data;
    }
}

export interface ITechnology {
    id?: number;
    queryId?: string;
    queryUploadedAt?: Date;
    queryCategory?: string | undefined;
    gadgetname?: string | undefined;
    description?: string | undefined;
    launchdate?: Date | undefined;
    prize?: number | undefined;
}

export class Universities implements IUniversities {
    id?: number;
    queryId?: string;
    queryUploadedAt?: Date;
    queryCategory?: string | undefined;
    universityname?: string | undefined;
    courseOffered?: string | undefined;
    description?: string | undefined;
    fee?: number | undefined;
    establishedYear?: Date | undefined;
    location?: string | undefined;

    constructor(data?: IUniversities) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.queryId = _data["queryId"];
            this.queryUploadedAt = _data["queryUploadedAt"] ? new Date(_data["queryUploadedAt"].toString()) : <any>undefined;
            this.queryCategory = _data["queryCategory"];
            this.universityname = _data["universityname"];
            this.courseOffered = _data["courseOffered"];
            this.description = _data["description"];
            this.fee = _data["fee"];
            this.establishedYear = _data["establishedYear"] ? new Date(_data["establishedYear"].toString()) : <any>undefined;
            this.location = _data["location"];
        }
    }

    static fromJS(data: any): Universities {
        data = typeof data === 'object' ? data : {};
        let result = new Universities();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["queryId"] = this.queryId;
        data["queryUploadedAt"] = this.queryUploadedAt ? this.queryUploadedAt.toISOString() : <any>undefined;
        data["queryCategory"] = this.queryCategory;
        data["universityname"] = this.universityname;
        data["courseOffered"] = this.courseOffered;
        data["description"] = this.description;
        data["fee"] = this.fee;
        data["establishedYear"] = this.establishedYear ? this.establishedYear.toISOString() : <any>undefined;
        data["location"] = this.location;
        return data;
    }
}

export interface IUniversities {
    id?: number;
    queryId?: string;
    queryUploadedAt?: Date;
    queryCategory?: string | undefined;
    universityname?: string | undefined;
    courseOffered?: string | undefined;
    description?: string | undefined;
    fee?: number | undefined;
    establishedYear?: Date | undefined;
    location?: string | undefined;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    readonly temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            (<any>this).temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}